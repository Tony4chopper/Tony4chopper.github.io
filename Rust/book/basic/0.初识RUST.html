<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>初识RUST</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../开端.html">写在开端</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">初学路上的所思所想</li><li class="chapter-item expanded "><a href="../basic/0.初识RUST.html" class="active"><strong aria-hidden="true">1.</strong> 初识RUST</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../practice/0.解析个IP报文吧.html"><strong aria-hidden="true">1.1.</strong> 自己想的小Demo</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/1.闭包、迭代器.html"><strong aria-hidden="true">2.</strong> 闭包与迭代器</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="初识rust"><a class="header" href="#初识rust">初识RUST</a></h1>
<blockquote>
<p>本篇主要是在初学完《RUST圣经》基础篇后，对RUST语言的初认知。总结出我认为对于一个C/C++的程序员，在刚接触RUST之后的大体印象（即RUST的特点？），旨在一文让人对RUST有初步了解。</p>
</blockquote>
<h2 id="1关于rust需要明确的几个概念"><a class="header" href="#1关于rust需要明确的几个概念">1、关于RUST需要明确的几个概念</a></h2>
<ul>
<li>
<p><strong>变量相关</strong></p>
<ul>
<li><code>let a = "It's a &amp;str"</code>，在rust语言中这个语句被称作为<strong>变量绑定</strong>，这个过程如何理解呢？感觉可以看作<code>"It's a &amp;str"</code>这个常量是存在栈内存上，上述语句是先创建了一个变量<code>a</code>，再把常量对象（对应内存）的<strong>所有权</strong>给到了变量a。主要是为了内存安全;</li>
<li>可变与不可变，在变量声明时用<code>mut</code>区分;</li>
<li>变量解构：类似于匹配</li>
</ul>
</li>
<li>
<p><strong>所有权</strong></p>
<ul>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者;</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者;
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("hello");//变量s1是String类型的hello的所有者
//String类型是可变长的字符串，它是存在堆上的
let s2 = s1;//这里hello的所有权发生了转移
println!("{}, world!", s1);//s1是个无效引用，所以报错
<span class="boring">}</span></code></pre></pre>
这么做的好处就在于一定程度上避免了内存二次释放的风险;
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;//这里并没有发生所有权的转移，而是在栈上对值5做了拷贝
println!("x = {}, y = {}", x, y);
<span class="boring">}</span></code></pre></pre>
</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop);</li>
</ul>
</li>
<li>
<p><strong>引用与借用</strong></p>
<ul>
<li>获取变量的引用称之为借用，允许你使用值，但是不获取<strong>所有权</strong>（因此引用的变量离开作用于之后也不会释放引用指向的值）;</li>
<li>可变引用与不可变引用的使用规则</li>
<li><strong>可变引用</strong>同时只能存在一个：<strong>同一作用域，特定数据只能有一个可变引用</strong>，避免多个指操作一个数据的数据竞争问题</li>
<li>可变引用与不可变引用<strong>不能同时存在</strong>：对于引用的作用域而言的。好处是避免数据污染，不可变引用肯定是不希望自己指向的值被改变的。
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("hello");
let r1 = &amp;s; // 没问题
let r2 = &amp;s; // 没问题
let r3 = &amp;mut s; // 大问题
println!("{}, {}, and {}", r1, r2, r3);
//但s被改了其实，r1和r2也就被改了
<span class="boring">}</span></code></pre></pre>
</li>
<li>编译器会保障引用的作用域结束前，数据是不会先释放的（不然会编译错误）有效避免空指针的情况；</li>
</ul>
</li>
</ul>
<h2 id="2对rust几个关键特点的认知与联系"><a class="header" href="#2对rust几个关键特点的认知与联系">2、对RUST几个关键特点的认知与联系</a></h2>
<blockquote>
<p>通过泛型、特性、方法三者的概念与彼此间的关系来对rust有个初步认识</p>
</blockquote>
<ul>
<li>
<p>类型：许多类型和其他编程语言大差不差，这里对有所区别的情况做个说明；</p>
<ul>
<li>数值类型：NaN，is_nan(),as做类型转换</li>
<li>字符类型：中文在UTF-8中占三个字节</li>
<li>切片：对集合类型的部分连续的元素序列的引用，所以对中文字符串的切片引用要注意索引</li>
<li>元组：<code>let x: (i32, f64, u8) = (500, 6.4, 1);let six_point_four = x.1;</code></li>
<li><strong>结构体</strong>：结构体中的字段所有权转移出去后，则无法访问该字段，但可以访问其他字段</li>
<li><strong>枚举</strong>：枚举的功能非常强大，任何数据类型都可以放到枚举成员中。它是一种创建一组相关值的类型。每个枚举成员都可以包含不同类型的数据，但这些成员都属于同一个枚举类型。
<pre><pre class="playground"><code class="language-rust">enum Message {
   Quit,//没有任何关联数据
   Move { x: i32, y: i32 },//包含一个匿名结构体
   Write(String),//包含一个String字符串
   ChangeColor(i32, i32, i32),//包含三个i32
}

fn main() {
   let m1 = Message::Quit;
   let m2 = Message::Move{x:1,y:1};
   let m3 = Message::ChangeColor(255,255,0);
}</code></pre></pre>
还可以为枚举实现方法，特性等，感觉极大加强枚举类型的功能</li>
<li>泛型：和其他语言的语法也大差不差，区别在于可以对泛型指定对应的特征。如下：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {
   //fn 函数名&lt;T:指定特征&gt;(函数参数:T类型)-&gt;返回类型T
   a + b//不带分号，标识直接返回
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>方法：</p>
<ul>
<li>通过<code>impl</code>来定义方法：类似于其他语言的Class，只不过方法和数据结构体是分离的
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Circle {
   x: f64,
   y: f64,
   radius: f64,
}

impl Circle {
// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字
// 这种方法往往用于初始化当前结构体的实例
fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
   Circle {
      x: x,
      y: y,
      radius: radius,
   }
}

// Circle的方法，&amp;self表示借用当前的Circle结构体
fn area(&amp;self) -&gt; f64 {
      std::f64::consts::PI * (self.radius * self.radius)
   }
}

<span class="boring">}</span></code></pre></pre>
</li>
<li><code>self、&amp;self、&amp;mut self</code>：<strong>所有权</strong></li>
<li><code>self</code> 表示 <code>Circle</code> 的所有权转移到该方法中，这种形式用的较少</li>
<li><code>&amp;self</code> 表示该方法对 <code>Circle</code> 的不可变借用</li>
<li><code>&amp;mut self</code> 表示可变借用</li>
<li>可以用为一个结构体定义多个impl块，便于把相关的方法放在一起</li>
<li>关联函数：在<code>impl</code>中与结构体关联紧密，但不使用<code>self</code>，因此他是函数而不是方法（<strong>无法x.area()这么调用、而是用Circle::new()</strong>）</li>
<li>可以为枚举实现方法====&gt;很好用的特殊结构体？</li>
</ul>
</li>
<li>
<p><strong>特性Trait（非常重要）</strong>:一组可以被共享的行为，只要实现了特征，你就能使用这组行为，让不同的类型能有共同的特征（这个特征只是定义了接口，具体的时间根据自己的类型来，有点类似于抽象类？）</p>
<ul>
<li>定义特征：特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是;，而不是一个 {}。
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
      fn summarize(&amp;self) -&gt; String;
   }
<span class="boring">}</span></code></pre></pre>
</li>
<li>可以为类型实现特征，类似于结构体中实现方法，举个例子；
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
   fn summarize(&amp;self) -&gt; String;
}
pub struct Post {
   pub title: String, // 标题
   pub author: String, // 作者
   pub content: String, // 内容
}

impl Summary for Post {
   fn summarize(&amp;self) -&gt; String {
      format!("文章{}, 作者是{}", self.title, self.author)
   }
}

pub struct Weibo {
   pub username: String,
   pub content: String
}

impl Summary for Weibo {
   fn summarize(&amp;self) -&gt; String {
      format!("{}发表了微博{}", self.username, self.content)
   }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>特征作为函数参数——<strong>只要实现了这个特征的类型都能作为函数入参</strong>；</li>
<li>特征约束——类似<code>let b:i16 = 3;</code>这里的i16可以换成特征，作为变量的特征约束；</li>
<li>特征相关的内容还特别多，感觉是rust中非常重要的特性，这里只是大致说明一下是什么就行，如何更好运用以及特点待后续更多的学习。</li>
</ul>
</li>
<li>
<p>通过泛型、方法、特征三者均赋予类型极高的灵活性，让结构体、枚举这样的类型有了更多的可拓展性。目前对这些特性的初步认知，rust可以实现面向对象、多态、代码抽象、复用等特性。</p>
</li>
</ul>
<h2 id="3基本语法形式"><a class="header" href="#3基本语法形式">3、基本语法形式</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a:i32 = 5; let mut b = 6;//可变与不可变变量，指定i32的类型；
let x = 5; let y = &amp;x; assert_eq!(5,*y);//引用与解引用；
println!("{},{}",a,b);//打印，{}作为占位符，有Display特性就行；

let mut a = String::from("hi");
let b = &amp;a;//不可变引用
let mut c = &amp;a;//可变引用
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)] // 允许编译器忽略未使用的代码

use std::fmt; // 引入格式化库
use std::fmt::{Display}; // 引入Display特征

// 定义一个枚举类型，表示文件状态
#[derive(Debug,PartialEq)] // 自动派生Debug和PartialEq特性
enum FileState {
   Open, // 文件打开状态
   Closed, // 文件关闭状态
}

// 定义一个结构体，表示文件
#[derive(Debug)] // 自动派生Debug特性
struct File {
   name: String, // 文件名
   data: Vec&lt;u8&gt;, // 文件数据
   state: FileState, // 文件状态
}

// 为FileState实现Display特性，用于格式化输出
impl Display for FileState {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
      match *self {
         FileState::Open =&gt; write!(f, "OPEN"), // 当状态为Open时，输出"OPEN"
         FileState::Closed =&gt; write!(f, "CLOSED"), // 当状态为Closed时，输出"CLOSED"
      }
   }
}

// 为File实现Display特性，用于格式化输出
impl Display for File {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
      write!(f, "&lt;{} ({})&gt;", // 格式化输出文件名和状态
      self.name, self.state) // 使用self.state调用Display特性的fmt方法来格式化状态
   }
}

// 为File实现new方法，用于创建新的File实例
impl File {
fn new(name: &amp;str) -&gt; File {
   File {
      name: String::from(name), // 将传入的文件名转换为String并存储
      data: Vec::new(), // 初始化一个空的Vec作为文件数据
      state: FileState::Closed, // 默认文件状态为Closed
      }
   }
}

fn main() {
let f6 = File::new("f6.txt"); // 创建一个新的File实例
   //...
   println!("{:?}", f6); // 打印文件的详细信息（调试模式）
   println!("{}", f6); // 打印文件的简要信息（非调试模式）
}</code></pre></pre>
<h2 id="4项目代码文件构成"><a class="header" href="#4项目代码文件构成">4、项目代码文件构成</a></h2>
<blockquote>
<ul>
<li>Packages:项目、软件包 一个 Cargo 提供的 feature，可以用来构建、测试和分享包</li>
<li>Crate：包，一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li>Module：模块，可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元，语法：<code>mod my_module;</code></li>
<li>对于<code>crate</code>和<code>module</code>关系的理解：https://zhuanlan.zhihu.com/p/164556350</li>
</ul>
</blockquote>
<p>典型的package结构</p>
<pre><code class="language-txt">.
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── bin
│       └── main1.rs
│       └── main2.rs
├── tests
│   └── some_integration_tests.rs
├── benches
│   └── simple_bench.rs
└── examples
    └── simple_example.rs
</code></pre>
<ul>
<li>唯一库包：src/lib.rs</li>
<li>默认二进制包：src/main.rs，编译后生成的可执行文件与 Package 同名</li>
<li>其余二进制包：src/bin/main1.rs 和 src/bin/main2.rs，它们会分别生成一个文件同名的二进制可执行文件</li>
<li>集成测试文件：tests 目录下</li>
<li>基准性能测试 benchmark 文件：benches 目录下</li>
<li>项目示例：examples 目录下</li>
</ul>
<blockquote>
<p>rust里是通过use xxx来导入其他文件的模块，并简化写法；对于toml文件中引入的外部依赖，代码中可以直接用，也可以用use来简写</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../开端.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../practice/0.解析个IP报文吧.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../开端.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../practice/0.解析个IP报文吧.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
